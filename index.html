<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>React Fiber</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/night.css" />

    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-transition="zoom">
          <h2 class="r-fit-text">React Fiber</h2>
          <h4>우아한테크코스 7기 프론트엔드 피터</h4>
        </section>

        <section class="r-stack">
          <h3>
            리액트를 사용하며 <br />
            이런 궁금증 가져보신 적 있으신가요?
          </h3>
          <div class="fragment fade-in-then-semi-out">
            의문 1) setState를 호출했는데 <b>왜</b> 바로 상태에 반영이<br />
            바로 안되지?
            <pre>
                <code data-trim class="language-typescript">
                  const [count,setCount] = useCount(0);
                  
                  const handleClick = () => {
                    setCount(count+1); 
                    console.log(count); // 0
                    setCount(count+1); 
                    console.log(count); // 0
                  }
                </code>
              </pre>
          </div>
          <div class="fragment fade-in-then-semi-out">
            의문 2) 훅을 if문이나 함수 안에서 <b>왜</b> 호출하면 안되지?
            <pre>
                <code data-trim class="language-typescript">
                  if(condition){
                    const [state,setState] = useState(0);
                  }
                </code>
              </pre>
          </div>
          <div class="fragment fade-in-then-semi-out">
            의문 3) props로 전달한 값이나 상태값은<br />
            <b>어디서</b> 관리를 하는 걸까?
          </div>
        </section>

        <section>
          <h2>=> React Fiber</h2>
          <p class="fragment fade-in">: 리액트의 내부 동작 원리</p>
        </section>

        <section>
          <h2>
            Q) 내부 동작 원리를 <span class="fragment highlight-red">왜</span>
            <br />
            알아야하지?
          </h2>
          <p>내부 동작 원리를 몰라도 개발하는데 지장이 없지 않을까?</p>
          <ul>
            <li class="fragment fade-in">
              프론트엔드 개발의 전체적인 그림을 그리기 위해서
            </li>
            <li class="fragment fade-in">
              리액트의 핵심 기술(RSC, Suspense, 동시성)을 빠르고 쉽게 이해하기
              위해서
            </li>
            <li class="fragment fade-in">
              하지만 개발을 하는데 필요한 지식을 학습하는 게 우선
            </li>
            <li class="fragment fade-in">
              이번 발표에서는 '리액트 내부에는 이런게 있구나', 그리고 '이런
              개념과 관련이 있구나' 정도로만 이해하면 충분
            </li>
          </ul>
        </section>

        <section>
          <h2>목차</h2>
          <ol>
            <li>React Fiber의 등장 배경</li>
            <li>React Fiber란?</li>
            <li>React Fiber의 내부 구조</li>
          </ol>
        </section>

        <section>
          <section>
            <h2>1. React Fiber의 등장 배경</h2>
          </section>
          <section>
            <h3>React16 이전 : 스택 재조정자</h3>
            <div class="fragment fade-in-then-semi-out">
              <p>: 렌더링 작업을 순차적으로 처리</p>
              <img src="./images/stack.png" />
            </div>
            <p class="fragment fade-in">단점</p>
            <ol>
              <li class="fragment fade-in">중간에 작업을 중단할 수 없다.</li>
              <li class="fragment fade-in">순서를 변경할 수 없다.</li>
            </ol>
            <p class="fragment fade-in">=> Fiber 등장</p>
          </section>
        </section>

        <section>
          <section>
            <h2>2. React Fiber란?</h2>
            <p class="fragment fade-in">두 가지 개념</p>
            <ol>
              <li class="fragment fade-in">Fiber Architecture</li>
              <li class="fragment fade-in">Fiber Node</li>
            </ol>
          </section>

          <section>
            <h3>1) Fiber Architecture</h3>
            <p class="fragment fade-in">: 새로운 재조정 엔진</p>
            <ol>
              <li class="fragment fade-in">
                각 작업을 작은 단위로 나누어 렌더링
              </li>
              <li class="fragment fade-in">중단 가능한 작업</li>
              <li class="fragment fade-in">각 작업에 우선순위 지정</li>
              <p class="fragment fade-in">=> 동시성 모드 지원</p>
            </ol>
          </section>

          <section>
            <h3>2) Fiber Node</h3>
            <p class="fragment fade-in">
              : 컴포넌트의 데이터를 저장하는 자바스크립트 객체
            </p>
            <ol>
              <li class="fragment fade-in">
                컴포넌트의 타입, 상태, DOM 참조 등의 정보를 포함
              </li>
            </ol>
            <p class="fragment fade-in">=> 함수형 컴포넌트에서 훅 지원</p>
          </section>
        </section>

        <section>
          <section>
            <h2>3. React Fiber의 <br />내부 구조</h2>
          </section>
          <section>
            <a
              href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiber.js"
              target="_blank"
              style="font-size: 20px"
              >react/packages/react-reconciler/ReactFiber.js</a
            >
            <pre style="height: 680px; font-size: 16px">
							<code data-trim data-noescape class="language-javascript" data-line-numbers="|1-7,33|1,9-15|1,9,17-22|1,24-32,33|1,19,33|1,19,20,33">
export type Fiber = {
  // Instance
  tag: WorkTag;
  key: null | string;
  elementType: any;
  type: any;
  stateNode: any;

  // Fiber
  return: Fiber | null;
  child: Fiber | null;
  sibling: Fiber | null;
  index: number;
  ref: RefObject;
  refCleanup: null | (() => void);

  pendingProps: any;
  memoizedProps: any;
  updateQueue: mixed;
  memoizedState: any;
  dependencies: Dependencies | null;
  mode: TypeOfMode;

  // Effects
  flags: Flags;
  subtreeFlags: Flags;
  deletions: Array<Fiber> | null;

  lanes: Lanes;
  childLanes: Lanes;

  alternate: Fiber | null;
};
								</code>
							</pre>
          </section>

          <section>
            <h2>3.1. updateQueue</h2>

            <div class="fragment fade-in-then-semi-out">
              의문 1) setState를 호출했는데 <b>왜</b> 상태에 바로 반영이<br />
              바로 안되지?
              <pre>
                <code data-trim class="language-typescript">
                  const [count,setCount] = useCount(0);
                  
                  const handleClick = () => {
                    setCount(count+1); 
                    console.log(count); // 0
                    setCount(count+1); 
                    console.log(count); // 0
                  }
                </code>
              </pre>
            </div>

            <p class="fragment fade-in">: 상태 업데이트를 관리하는 큐</p>
            <ul>
              <li class="fragment fade-in">
                setState를 updateQueue에 추가하고, <br />렌더링 주기가 끝날 때
                업데이트를 한 번에 처리
              </li>
              <a
                class="fragment fade-in"
                href="https://ko.react.dev/learn/queueing-a-series-of-state-updates"
                >=> 리액트의 Batch 업데이트</a
              >
            </ul>
          </section>

          <section>
            <h2>3.2. memoizedState</h2>

            <div class="fragment fade-in-then-semi-out">
              의문 2) 훅을 if문이나 함수 안에서 <b>왜</b> 호출하면 안되지?
              <pre>
                <code data-trim class="language-typescript" data-line-numbers="">
                  if(condition){
                    const [state,setState] = useState(0);
                  }
                </code>
              </pre>
            </div>
            <div class="fragment fade-in-then-semi-out">
              의문 3) props로 전달한 값이나 상태값은<br />
              <b>어디서</b> 관리를 하는 걸까?
            </div>
          </section>

          <section>
            <h2>3.2. memoizedState</h2>

            <pre class="fragment fade-in">
              <code class="language-javascript" data-trim data-line-numbers="|1,2,3,9|1,5-7,9|">
                function ExampleComponent() {
                  const [count, setCount] = useState(0);         // 1번째 Hook
                  const [text, setText] = useState('hi');        // 2번째 Hook

                  useEffect(() => {                              // 3번째 Hook
                    document.title = text + count;
                  }, [text, count]);
                  // ..
                }
              </code>
            </pre>
            <pre class="fragment fade-in">
              <code class="language-javascript" data-trim data-line-numbers="|1,3,5,7,8,9,10|1,2,10|1,3,4,9,10|1,5,6,8,10|1,7,10|">
                Fiber.memoizedState = {
                  memoizedState: 0, // useState(0)
                  next: {
                    memoizedState: 'hi', // useState('hi')
                    next: {
                      memoizedState: { deps: ['hi', 0], ... }, // useEffect
                      next: null
                    }
                  }
                }
              </code>
            </pre>
          </section>

          <section>
            <h2>2) memoizedState</h2>
            <ul>
              <li class="fragment fade-in">리액트의 상태와 훅을 저장</li>
              <p class="fragment fade-in">
                => 함수형 컴포넌트가 리렌더링해도 훅의 이전 상태를 기억
              </p>
              <li class="fragment fade-in">연결 리스트 형태로 저장</li>
              <p class="fragment fade-in">
                => 훅을 if문이나 함수 안에서 왜 호출하면 안된다.
              </p>
            </ul>
          </section>

          <section>
            <h2>3.3. 그 외</h2>
            <ul>
              <li class="fragment fade-in">
                <b>lanes</b> : 작업 우선순위를 관리
                <p>=> 동시성 모드</p>
              </li>
              <li class="fragment fade-in">
                <b>alternate</b> : 현재 트리와 작업 중인 트리<br/> 사이의 연결을 관리
                <p>=> 재조정</p>
              </li>
              <li class="fragment fade-in">
                <b>memoizedProps / pendingProps</b> 
                <p>: 컴포넌트의 props를 관리</p>
              </li>
            </ul>
          </section>
        </section>

        <section>감사합니다.</section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/search/search.js"></script>
    <script>
      Reveal.initialize({
        hash: true,
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
          RevealZoom,
          RevealSearch,
        ],
        controls: true,
        autoAnimateStyles: [
          "opacity",
          "color",
          "background-color",
          "padding",
          "font-size",
          "line-height",
          "letter-spacing",
          "border-width",
          "border-color",
          "border-radius",
          "outline",
          "outline-offset",
        ],
        margin: 0.2,
      });
    </script>
  </body>
</html>
